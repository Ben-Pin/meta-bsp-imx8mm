From 34c48d8cd4d53c724fce683cb0e0490d1470e47c Mon Sep 17 00:00:00 2001
From: Kirill Kapranov <kirill.kapranov@compulab.co.il>
Date: Tue, 10 May 2022 23:30:00 +0300
Subject: [PATCH 42/42] snd: Fix resource management

Allocation of the memory and creating sysfs group shall be undone in case of
error. This prevents memory leak; also this rids system log of unnecessary
pollution caused by attempts of sysfs group recreation.

Signed-off-by: Kirill Kapranov <kirill.kapranov@compulab.co.il>
---
 sound/soc/fsl/fsl_sai.c     | 50 +++++++++++++++++++++++++++++----------------
 sound/soc/fsl/imx-pcm-dma.c |  9 +++++---
 2 files changed, 38 insertions(+), 21 deletions(-)

diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 5e3253cfc790..df5d0973fa71 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -1305,7 +1305,7 @@ static int fsl_sai_read_dlcfg(struct platform_device *pdev, char *pn,
 static int fsl_sai_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
-	struct fsl_sai *sai;
+	struct fsl_sai *sai = NULL;
 	struct regmap *gpr;
 	void __iomem *base;
 	char tmp[8];
@@ -1313,8 +1313,10 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	int index;
 
 	sai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);
-	if (!sai)
-		return -ENOMEM;
+	if (!sai) {
+		ret = -ENOMEM;
+		goto general_finish;
+	}
 
 	sai->pdev = pdev;
 	sai->soc_data = of_device_get_match_data(&pdev->dev);
@@ -1323,8 +1325,10 @@ static int fsl_sai_probe(struct platform_device *pdev)
 
 	sai->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, sai->res);
-	if (IS_ERR(base))
-		return PTR_ERR(base);
+	if (IS_ERR(base)) {
+		ret = PTR_ERR(base);
+		goto err_mem_free;
+	}
 
 	if (sai->soc_data->reg_offset == 8) {
 		fsl_sai_regmap_config.reg_defaults = fsl_sai_reg_defaults_ofs8;
@@ -1337,7 +1341,8 @@ static int fsl_sai_probe(struct platform_device *pdev)
 			NULL, base, &fsl_sai_regmap_config);
 	if (IS_ERR(sai->regmap)) {
 		dev_err(&pdev->dev, "regmap init failed\n");
-		return PTR_ERR(sai->regmap);
+		ret = PTR_ERR(sai->regmap);
+		goto err_mem_free;
 	}
 
 	/* No error out for old DTB cases but only mark the clock NULL */
@@ -1345,8 +1350,8 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	if (IS_ERR(sai->bus_clk)) {
 		dev_err(&pdev->dev, "failed to get bus clock: %ld\n",
 				PTR_ERR(sai->bus_clk));
-		return PTR_ERR(sai->bus_clk);
-		sai->bus_clk = NULL;
+		ret = PTR_ERR(sai->bus_clk);
+		goto err_mem_free;
 	}
 
 	for (i = 0; i < FSL_SAI_MCLK_MAX; i++) {
@@ -1374,14 +1379,14 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	ret = fsl_sai_read_dlcfg(pdev, "fsl,dataline", &sai->pcm_dl_cfg,
 					sai->soc_data->dataline);
 	if (ret < 0)
-		return ret;
+		goto err_mem_free;
 
 	sai->pcm_dl_cfg_cnt = ret;
 
 	ret = fsl_sai_read_dlcfg(pdev, "fsl,dataline,dsd", &sai->dsd_dl_cfg,
 					sai->soc_data->dataline);
 	if (ret < 0)
-		return ret;
+		goto err_mem_free;
 
 	sai->dsd_dl_cfg_cnt = ret;
 
@@ -1400,14 +1405,16 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
+	if (irq < 0) {
+		ret = irq;
+		goto err_mem_free;
+	}
 
 	ret = devm_request_irq(&pdev->dev, irq, fsl_sai_isr, IRQF_SHARED,
 			       np->name, sai);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to claim irq %u\n", irq);
-		return ret;
+		goto err_mem_free;
 	}
 
 	memcpy(&sai->cpu_dai_drv, &fsl_sai_dai_template,
@@ -1424,7 +1431,8 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	    of_find_property(np, "fsl,sai-asynchronous", NULL)) {
 		/* error out if both synchronous and asynchronous are present */
 		dev_err(&pdev->dev, "invalid binding for synchronous mode\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_mem_free;
 	}
 
 	if (of_find_property(np, "fsl,sai-synchronous-rx", NULL)) {
@@ -1445,12 +1453,15 @@ static int fsl_sai_probe(struct platform_device *pdev)
 		gpr = syscon_regmap_lookup_by_compatible("fsl,imx6ul-iomuxc-gpr");
 		if (IS_ERR(gpr)) {
 			dev_err(&pdev->dev, "cannot find iomuxc registers\n");
-			return PTR_ERR(gpr);
+			ret = PTR_ERR(gpr);
+			goto err_mem_free;
 		}
 
 		index = of_alias_get_id(np, "sai");
-		if (index < 0)
-			return index;
+		if (index < 0) {
+			ret = index;
+			goto err_mem_free;
+		}
 
 		regmap_update_bits(gpr, IOMUXC_GPR1, MCLK_DIR(index),
 				   MCLK_DIR(index));
@@ -1506,7 +1517,7 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	regcache_cache_only(sai->regmap, true);
 
 	ret = devm_snd_soc_register_component(&pdev->dev, &fsl_component,
-					      &sai->cpu_dai_drv, 1);
+		sysfs_create_group			      &sai->cpu_dai_drv, 1);
 	if (ret)
 		goto err_component_register;
 
@@ -1530,6 +1541,9 @@ static int fsl_sai_probe(struct platform_device *pdev)
 err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
 
+err_mem_free:
+	devm_kfree(&pdev->dev, sai);
+
 	return ret;
 }
 
diff --git a/sound/soc/fsl/imx-pcm-dma.c b/sound/soc/fsl/imx-pcm-dma.c
index 04a9bc749016..25ef5e0e6681 100644
--- a/sound/soc/fsl/imx-pcm-dma.c
+++ b/sound/soc/fsl/imx-pcm-dma.c
@@ -37,6 +37,7 @@ static const struct snd_dmaengine_pcm_config imx_dmaengine_pcm_config = {
 int imx_pcm_dma_init(struct platform_device *pdev, size_t size)
 {
 	struct snd_dmaengine_pcm_config *config;
+	int ret;
 
 	config = devm_kzalloc(&pdev->dev,
 			sizeof(struct snd_dmaengine_pcm_config), GFP_KERNEL);
@@ -44,9 +45,11 @@ int imx_pcm_dma_init(struct platform_device *pdev, size_t size)
 		return -ENOMEM;
 	*config = imx_dmaengine_pcm_config;
 
-	return devm_snd_dmaengine_pcm_register(&pdev->dev,
-		config,
-		SND_DMAENGINE_PCM_FLAG_COMPAT);
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, config,
+			SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if(ret)
+		devm_kfree(&pdev->dev, config);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(imx_pcm_dma_init);
 
-- 
2.11.0

